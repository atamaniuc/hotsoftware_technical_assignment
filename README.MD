### Тестовое задание: Проверка достижимости значения путем сложения двух чисел
```
Даны три целые числа a, b, c больше 0. Есть два варианта либо добавлять b к a (a+=b), либо добавлять a к b (b+=a).  
В результате получаются новые значение а и b. 
Напишите программу на NODE JS, которая выведет YES или NO в зависимости от того можете ли получить значение c, добавляя a к b или b к a друг к другу.

P.S. где с не ограничено большое значение
```
![img.png](img.png)

### Установка и запуск
1. `git clone git@github.com:atamaniuc/hotsoftware_technical_assignment.git` или `gh repo clone atamaniuc/hotsoftware_technical_assignment`
2. `cd technical_assignment`
3. `nvm use v22.4.1`
4. `npm i`
5. `node app.js`

![img_2.png](img_2.png)

6. `node test.js`

![img_3.png](img_3.png)

### Описание работы

Этот проект включает реализацию алгоритма для проверки возможности достижения заданного числа `c` путём сложения чисел `a` и `b`. Реализована оптимизация через использование `Breadth-First Search` (BFS) для эффективного обхода возможных комбинаций чисел.

### Основные компоненты

#### 1. Основной файл `app.js`

Основной файл выполняет следующие функции:
- Запрашивает у пользователя ввод чисел `a`, `b` и `c`.
- Проверяет корректность ввода.
- Вызывает функцию для проверки возможности достижения числа `c`.
- Отображает результат и время выполнения.

#### 2. Проверка корректности ввода

Функция `isValidInput` проверяет, что все введенные значения являются положительными целыми числами, и что `c` не меньше суммы `a` и `b`.

#### 3. Расчет наибольшего общего делителя (НОД)

```
// Greatest Common Divisor (GCD)
const gcd = (x, y) => {
    while (y !== 0) {
        [x, y] = [y, x % y];
    }
    return x;
}
```
Назначение: Вычисляет наибольший общий делитель `(НОД)` двух чисел x и y.
Алгоритм: Использует алгоритм Евклида, эффективный метод нахождения `НОД`.
Временная сложность: `O(log(min(x, y)))` - логарифмическое время, очень эффективно.
#### 4. Основной алгоритм `canReachSum`

Функция `canReachSum` использует алгоритм поиска в ширину (Breadth-First Search, BFS) для обхода всех возможных комбинаций чисел `a` и `b`, которые могут быть получены путём их сложения.

### Функция canReachSum(a, b, c)

```javascript
const canReachSum = (a, b, c) => {
    if (c % gcd(a, b) !== 0) {
        return false;
    }

    const visited = new Set();
    const queue = [[a, b]];

    while (queue.length > 0) {
        const [currentA, currentB] = queue.shift();

        if (currentA === c || currentB === c) {
            return true;
        }

        const nextA = currentA + currentB;
        const nextB = currentB + currentA;

        if (nextA <= c && !visited.has(`${nextA},${currentB}`)) {
            visited.add(`${nextA},${currentB}`);
            queue.push([nextA, currentB]);
        }

        if (nextB <= c && !visited.has(`${currentA},${nextB}`)) {
            visited.add(`${currentA},${nextB}`);
            queue.push([currentA, nextB]);
        }
    }

    return false;
}
```

Назначение:

Определяет, можно ли получить целевую сумму c путем последовательного прибавления чисел a или b друг к другу.

Алгоритм:

Проверка делимости:

Использует функцию `gcd(a, b)` для вычисления наибольшего общего делителя `(НОД)` чисел `a` и `b`.
Если c не делится на `НОД` `a` и `b`, то c недостижима, и функция возвращает `false`.
Поиск в ширину `(Breadth-First Search, BFS)`:

Создает множество `visited` для отслеживания уже посещенных пар сумм.
Создает очередь `queue` для хранения пар сумм, которые еще предстоит обработать. Начальная пара: `[a, b]`.
Пока очередь не пуста:
Извлекает пару сумм `[currentA, currentB]` из начала очереди.
Если `currentA` или `currentB` равно `c`, то сумма достижима, и функция возвращает true.
В противном случае, вычисляет две новые суммы: `nextA = currentA + currentB` и `nextB = currentB + currentA`.
Если новые суммы не превышают `c` и еще не были посещены, добавляет их в очередь и помечает как посещенные.
Возврат результата:

Если очередь опустела и c не найдена, значит, сумма недостижима, и функция возвращает `false`.

### Сложность
**Временная сложность**: `O(c^2)` - в худшем случае, когда нужно рассмотреть все возможные комбинации сумм до `c`.

**Пространственная сложность**: `O(c^2)` - для хранения множества `visited` и очереди `queue`.

#### 5. Построение дерева (опционально)

Функция `buildTree` может быть использована для построения дерева всех возможных комбинаций чисел `a` и `b`.

- **Очередь**: Используется для хранения текущих узлов дерева.
- **Множество посещённых**: Используется для отслеживания уже проверенных узлов дерева.
- **Добавление узлов**: Новые узлы добавляются в дерево, если они не превышают `c` и ещё не были проверены.


### Скорость выполнения: обрабатывает c=20000 за ~ 2 min
```
time node app.js
Input "a": 5
Input "b": 7
Input "c": 20000

YES
Execution Time: 1:52.980 (m:ss.mmm)
node app.js  107.37s user 0.84s system 91% cpu 1:58.06 total
```
ранилось на `2,2 GHz 6-Core Intel Core i7`
